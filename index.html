<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Doctor Chat (Patient-Centric)</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #f0f2f5; height: 100vh; overflow: hidden; }
        .chat-container { display: flex; height: 100vh; max-width: 1200px; margin: 0 auto; background: white; box-shadow: 0 2px 20px rgba(0,0,0,0.1); }

        /* Sidebar */
        .sidebar { width: 380px; border-right: 1px solid #e4e6ea; display: flex; flex-direction: column; background: white; }
        .sidebar-header { padding: 16px; border-bottom: 1px solid #e4e6ea; background: #fff; }
        .connection-status { display: flex; align-items: center; gap: 8px; margin-bottom: 12px; padding: 8px 12px; border-radius: 8px; font-size: 14px; font-weight: 500; }
        .connection-status.connected { background: #d4edda; color: #155724; }
        .connection-status.disconnected { background: #f8d7da; color: #721c24; }
        .connection-status.connecting { background: #fff3cd; color: #856404; }
        .connection-status.error { background: #f8d7da; color: #721c24;}
        .auth-section textarea, .auth-section input { width: 100%; padding: 8px 12px; border: 1px solid #ddd; border-radius: 8px; resize: vertical; font-size: 12px; margin-bottom: 8px; }
        .btn { padding: 8px 16px; border: none; border-radius: 8px; cursor: pointer; font-weight: 500; transition: background-color 0.2s; }
        .btn-primary { background: #1877f2; color: white; }
        .btn-primary:hover:not(:disabled) { background: #166fe5; }
        .btn-danger { background: #e41e3f; color: white; }
        .btn-danger:hover:not(:disabled) { background: #d11a3b; }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; }

        .new-conversation-section { padding: 16px; border-bottom: 1px solid #e4e6ea;}
        .new-conversation-section input { width: 100%; padding: 8px 12px; margin-bottom:8px; border: 1px solid #ddd; border-radius: 8px; }


        .conversations-header { padding: 16px; border-bottom: 1px solid #e4e6ea; font-size: 18px; font-weight: 600; display: flex; justify-content: space-between; align-items: center; }
        .refresh-btn { background: none; border: none; cursor: pointer; font-size: 18px; padding: 4px; border-radius: 4px; }
        .refresh-btn:hover { background: #f0f2f5; }
        .conversations-list { flex: 1; overflow-y: auto; }
        .conversation-item { display: flex; padding: 12px 16px; cursor: pointer; transition: background-color 0.2s; border-bottom: 1px solid #f0f2f5; }
        .conversation-item:hover { background: #f0f2f5; }
        .conversation-item.active { background: #e7f3ff; border-right: 3px solid #1877f2; }
        .conversation-avatar { width: 50px; height: 50px; border-radius: 50%; background: #1877f2; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; margin-right: 12px; flex-shrink: 0; }
        .conversation-info { flex: 1; min-width: 0; }
        .conversation-name { font-weight: 600; margin-bottom: 2px; font-size: 14px; }
        .conversation-patient { font-size: 12px; color: #333; margin-bottom: 4px; font-style: italic;}
        .conversation-preview { color: #65676b; font-size: 13px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .conversation-meta { display: flex; flex-direction: column; align-items: flex-end; gap: 4px; }
        .conversation-time { color: #65676b; font-size: 12px; }
        .unread-badge { background: #e41e3f; color: white; border-radius: 50%; min-width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-size: 12px; font-weight: 600; }

        /* Chat Main */
        .chat-main { flex: 1; display: flex; flex-direction: column; background: white; }
        .chat-header { padding: 12px 16px; border-bottom: 1px solid #e4e6ea; display: flex; align-items: center; gap: 12px; background: white; }
        .chat-avatar { width: 40px; height: 40px; border-radius: 50%; background: #1877f2; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; }
        .chat-info h3 { font-size: 16px; margin-bottom: 2px; }
        .chat-info .patient-context { font-size: 13px; color: #444; font-style: italic;}
        .chat-status { color: #65676b; font-size: 12px; }
        .messages-container { flex: 1; overflow-y: auto; padding: 16px; background: #f0f2f5; position: relative; }
        .message-group { margin-bottom: 16px; }
        .message-date { text-align: center; color: #65676b; font-size: 12px; margin-bottom: 12px; background: white; display: inline-block; padding: 4px 12px; border-radius: 12px; margin: 0 auto 12px; display: block; width: fit-content; }
        .message { display: flex; margin-bottom: 2px; align-items: flex-end; position: relative; } /* Reduced margin, added relative */
        .message.own { flex-direction: row-reverse; }
        .message-bubble { max-width: 70%; padding: 10px 14px; border-radius: 18px; word-wrap: break-word; position: relative; }
        .message.own .message-bubble { background: #1877f2; color: white; border-bottom-right-radius: 4px; }
        .message:not(.own) .message-bubble { background: #e4e6ea; color: #050505; border-bottom-left-radius: 4px; }
        .message-time { font-size: 10px; color: #888; margin: 2px 8px 0; display: block; clear: both; } /* Changed, always visible */
        .message.own .message-time { text-align: right; }
        .message:not(.own) .message-time { text-align: left; }
        .message-read-status { font-size: 10px; color: #1877f2; margin-left: 5px; }
        .message-actions { display: none; position: absolute; top: -10px; background: white; border-radius: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.2); padding: 2px; z-index: 1; }
        .message:hover .message-actions { display: flex; }
        .message.own .message-actions { right: 0; margin-right: 5px; } /* Adjust based on bubble */
        .message:not(.own) .message-actions { left: 0; margin-left: 5px; }
        .message-action-btn { background: none; border: none; cursor: pointer; font-size: 12px; padding: 3px 5px; }

        .message-attachments { margin-top: 6px; }
        .attachment-item { display: inline-flex; align-items: center; gap: 6px; background: rgba(255,255,255,0.3); padding: 6px 10px; border-radius: 10px; margin: 4px 2px; font-size: 12px; border: 1px solid rgba(0,0,0,0.05); }
        .message:not(.own) .attachment-item { background: rgba(0,0,0,0.08); }
        .attachment-item a { color: inherit; text-decoration: none; }
        .attachment-item a:hover { text-decoration: underline; }

        .typing-indicator { display: flex; align-items: flex-end; margin: 0 16px 8px 16px; opacity: 0; transition: opacity 0.3s; height: 0; }
        .typing-indicator.show { opacity: 1; height: auto; margin-bottom: 8px; }
        .typing-bubble { background: #e4e6ea; padding: 10px 14px; border-radius: 18px; border-bottom-left-radius: 4px; }
        .typing-dots { display: flex; gap: 4px; }
        .typing-dot { width: 7px; height: 7px; background: #65676b; border-radius: 50%; animation: typing 1.4s infinite ease-in-out; }
        .typing-dot:nth-child(2) { animation-delay: 0.2s; }
        .typing-dot:nth-child(3) { animation-delay: 0.4s; }
        @keyframes typing { 0%, 60%, 100% { transform: translateY(0); } 30% { transform: translateY(-8px); } }

        .load-more { text-align: center; padding: 10px; margin-bottom: 10px; }
        .load-more button { background: #e0e0e0; color: #333; border: none; padding: 8px 16px; border-radius: 16px; cursor: pointer; font-size: 13px; }
        .load-more button:hover:not(:disabled) { background: #d0d0d0; }
        .load-more button:disabled { background: #f0f0f0; color: #aaa; cursor: not-allowed; }

        .message-input-container { padding: 12px 16px; border-top: 1px solid #e4e6ea; background: white; }
        .file-preview { margin-bottom: 8px; max-height: 80px; overflow-y: auto; }
        .file-item { display: flex; align-items: center; justify-content: space-between; padding: 6px 10px; margin: 4px 0; background: #f0f2f5; border-radius: 8px; font-size: 12px; }
        .file-info { display: flex; align-items: center; gap: 6px; flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .remove-file { background: none; border: none; cursor: pointer; color: #e41e3f; padding: 4px; border-radius: 4px; font-size: 14px; }
        .message-input-wrapper { display: flex; align-items: flex-end; gap: 8px; background: #f0f2f5; border-radius: 24px; padding: 6px 12px; }
        .message-input { flex: 1; border: none; background: none; outline: none; resize: none; max-height: 100px; font-size: 15px; font-family: inherit; line-height: 1.4; padding: 6px 0; }
        .input-actions { display: flex; gap: 6px; align-items: center; }
        .action-btn { background: none; border: none; cursor: pointer; padding: 8px; border-radius: 50%; display: flex; align-items: center; justify-content: center; transition: background-color 0.2s; font-size: 18px; color: #555; }
        .action-btn:hover { background: rgba(0,0,0,0.05); }
        .send-btn { background: #1877f2; color: white; }
        .send-btn:hover:not(:disabled) { background: #166fe5; }
        .send-btn:disabled { background: #bddefc; cursor: not-allowed; }

        .empty-state { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; color: #65676b; text-align: center; padding: 32px; }
        .empty-state h3 { margin-bottom: 8px; color: #1c1e21; }
        .scroll-to-bottom { position: absolute; bottom: 90px; right: 25px; background: #1877f2; color: white; border: none; border-radius: 50%; width: 40px; height: 40px; cursor: pointer; box-shadow: 0 2px 8px rgba(0,0,0,0.2); display: flex; align-items: center; justify-content: center; opacity: 0; transform: translateY(10px); transition: all 0.3s; z-index: 10; }
        .scroll-to-bottom.show { opacity: 1; transform: translateY(0); }
    </style>
</head>
<body>
<div class="chat-container">
    <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <div id="connectionStatus" class="connection-status disconnected">
                <span>🔴</span><span>Disconnected</span>
            </div>
            <div class="auth-section">
                <textarea id="tokenInput" placeholder="JWT Token..." rows="3"></textarea>
                <input type="text" id="serverUrl" value="http://localhost:3000" placeholder="Server URL"> <div style="display: flex; gap: 8px; margin-top: 8px;">
                <button id="connectBtn" class="btn btn-primary">Connect</button>
                <button id="disconnectBtn" class="btn btn-danger" disabled>Disconnect</button>
            </div>
                <p id="currentUserInfo" style="font-size: 12px; margin-top: 8px; color: #333;"></p>
            </div>
        </div>

        <div class="new-conversation-section">
            <h4 style="margin-bottom:8px; font-weight: 600;">Start New Discussion</h4>
            <input type="text" id="newPatientId" placeholder="Patient ID (UUID)">
            <input type="text" id="newDoctorId" placeholder="Other Doctor ID (UUID)">
            <button id="startNewConversationBtn" class="btn btn-primary" style="width:100%; margin-top:4px;" disabled>Start/Open Discussion</button>
        </div>

        <div class="conversations-header">
            <span>Discussions</span>
            <button class="refresh-btn" id="refreshConversations" title="Refresh" disabled>🔄</button>
        </div>
        <div class="conversations-list" id="conversationsList">
            <div class="empty-state"><h3>No discussions</h3><p>Connect to load.</p></div>
        </div>
    </div>

    <div class="chat-main">
        <div id="chatContent" class="empty-state">
            <h3>Welcome to Doctor Chat</h3>
            <p>Select a discussion about a patient to start messaging.</p>
        </div>
    </div>
</div>

<input type="file" id="fileInput" multiple accept="image/*,video/*,audio/*,.pdf,.doc,.docx,.txt,.zip,.rar" style="display: none;">

<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jwt-decode@3.1.2/build/jwt-decode.min.js"></script>

<script>
    class ChatApp {
        constructor() {
            this.socket = null;
            this.currentConversation = null; // { id: "partnerDoctorId-patientId", partnerDoctorId, patientId, patientName, partnerDoctorName, partnerDoctorAvatar, partnerDoctorSpecialty }
            this.conversations = new Map(); // Key: "partnerDoctorId-patientId", Value: conversation object from API
            this.messages = new Map(); // Key: "partnerDoctorId-patientId", Value: { messages: [], hasMore: true, nextCursor: null }
            this.currentUser = null; // { id: string (doctor's own associated_id), firstName: string, lastName: string }
            this.isTyping = false;
            this.typingTimeout = null;
            this.typingCleanupTimeout = null;
            this.selectedFiles = [];

            this.initializeElements();
            this.bindEvents();
            this.loadFromStorage();
        }

        initializeElements() {
            this.elements = {
                tokenInput: document.getElementById('tokenInput'),
                serverUrl: document.getElementById('serverUrl'),
                connectBtn: document.getElementById('connectBtn'),
                disconnectBtn: document.getElementById('disconnectBtn'),
                connectionStatus: document.getElementById('connectionStatus'),
                currentUserInfo: document.getElementById('currentUserInfo'),
                sidebar: document.getElementById('sidebar'),
                conversationsList: document.getElementById('conversationsList'),
                refreshConversations: document.getElementById('refreshConversations'),
                newPatientIdInput: document.getElementById('newPatientId'),
                newDoctorIdInput: document.getElementById('newDoctorId'),
                startNewConversationBtn: document.getElementById('startNewConversationBtn'),
                chatContent: document.getElementById('chatContent'),
                fileInput: document.getElementById('fileInput')
            };
        }

        bindEvents() {
            this.elements.connectBtn.addEventListener('click', () => this.connect());
            this.elements.disconnectBtn.addEventListener('click', () => this.disconnect());
            this.elements.refreshConversations.addEventListener('click', () => this.loadConversations());
            this.elements.fileInput.addEventListener('change', (e) => this.handleFileSelect(e));
            this.elements.startNewConversationBtn.addEventListener('click', () => this.handleStartNewConversation());
        }

        loadFromStorage() {
            const token = localStorage.getItem('chat_token');
            const serverUrl = localStorage.getItem('chat_server_url'); // Use chat_server_url to avoid conflict
            if (token) this.elements.tokenInput.value = token;
            if (serverUrl) this.elements.serverUrl.value = serverUrl;
        }

        saveToStorage() {
            localStorage.setItem('chat_token', this.elements.tokenInput.value);
            localStorage.setItem('chat_server_url', this.elements.serverUrl.value);
        }

        decodeJwt(token) {
            try {
                return jwt_decode(token);
            } catch (e) {
                console.error("Failed to decode JWT:", e);
                this.updateConnectionStatus('Invalid Token', 'error');
                return null;
            }
        }

        async connect() {
            const token = this.elements.tokenInput.value.trim();
            const url = this.elements.serverUrl.value.trim();

            if (!token) { alert('Please enter a JWT token'); return; }
            if (!url) { alert('Please enter a Server URL'); return; }

            this.saveToStorage();
            this.updateConnectionStatus('Connecting...', 'connecting');


            // Attempt to decode JWT to get user ID from associated_data.id (doctor's own ID)
            const decodedToken = this.decodeJwt(token);
            if (decodedToken && decodedToken.associated_data && decodedToken.associated_data.id) {
                // This is a placeholder, actual name comes from 'connected_user_info' event
                // The ID here is the doctor's own primary key from the 'doctors' table (associated_id)
                this.currentUser = { id: decodedToken.associated_data.id, firstName: "Loading", lastName: "User..." };
                this.elements.currentUserInfo.textContent = `Logged in as: ${this.currentUser.id.substring(0,8)}... (Verifying)`;
            } else {
                console.warn("Could not extract user ID (associated_data.id) from token structure immediately.");
                this.elements.currentUserInfo.textContent = `Awaiting server confirmation...`;
                // If you can't decode or structure is different, wait for server confirmation via 'connected_user_info'
            }


            if (this.socket) { this.socket.disconnect(); }
            this.socket = io(url, { auth: { token }, transports: ['websocket', 'polling'] });
            this.setupSocketEvents();
        }

        disconnect() {
            if (this.socket) { this.socket.disconnect(); }
            // State reset handled in 'disconnect' socket event
        }

        resetAppState() {
            this.socket = null;
            this.currentConversation = null;
            this.conversations.clear();
            this.messages.clear();
            this.currentUser = null; // Reset current user
            this.selectedFiles = [];
            this.elements.conversationsList.innerHTML = '<div class="empty-state"><h3>No discussions</h3><p>Connect to load.</p></div>';
            this.elements.chatContent.innerHTML = '<div class="empty-state"><h3>Welcome</h3><p>Select a discussion.</p></div>';
            this.elements.currentUserInfo.textContent = '';
            this.updateConnectionStatus('Disconnected', 'disconnected');
            this.updateButtons(false);
        }


        setupSocketEvents() {
            this.socket.on('connect', () => {
                // Status will be updated by 'connected_user_info' or error events
                // this.updateButtons(true) will be called after 'connected_user_info'
            });

            // This event confirms connection and provides the definite user info (including the ID used by the backend for this socket)
            this.socket.on('connected_user_info', (userInfo) => { // userInfo should be { id: string (doctor's associated_id), firstName: string, lastName: string }
                this.currentUser = userInfo; // The ID here is the one the backend associates with this socket
                this.elements.currentUserInfo.textContent = `Logged in as: ${this.currentUser.firstName} ${this.currentUser.lastName} (${this.currentUser.id.substring(0,8)}...)`;
                this.updateConnectionStatus('Connected', 'connected');
                this.updateButtons(true);
                this.loadConversations();
            });

            this.socket.on('disconnect', (reason) => {
                console.log('Disconnected:', reason);
                this.resetAppState();
            });

            this.socket.on('connect_error', (error) => {
                console.error('Connection error:', error);
                this.resetAppState(); // Full reset
                this.updateConnectionStatus(`Error: ${error.message}`, 'error');
            });

            this.socket.on('newMessage', (message) => this.handleNewMessage(message, false));
            this.socket.on('messageSent', (message) => this.handleNewMessage(message, true));
            this.socket.on('messageRead', (data) => this.handleMessageRead(data));
            this.socket.on('typing', (data) => this.handleTyping(data));
            this.socket.on('messageDeleted', (data) => this.handleMessageDeleted(data));
        }

        updateConnectionStatus(text, type) {
            const status = this.elements.connectionStatus;
            status.className = `connection-status ${type}`; // e.g., 'connected', 'disconnected', 'connecting', 'error'
            const emoji = type === 'connected' ? '🟢' : type === 'connecting' ? '🟡' : '🔴';
            status.innerHTML = `<span>${emoji}</span><span>${text}</span>`;
        }

        updateButtons(connected) {
            this.elements.connectBtn.disabled = connected;
            this.elements.disconnectBtn.disabled = !connected;
            this.elements.refreshConversations.disabled = !connected;
            this.elements.startNewConversationBtn.disabled = !connected;
        }

        async fetchApi(endpoint, options = {}) {
            if (!this.elements.tokenInput.value) { // Check token existence, currentUser might not be set yet during initial fetches
                console.error("Fetch API: Authentication token is missing.");
                // alert("Authentication token is missing. Please reconnect."); // Could be too intrusive
                return null;
            }
            const headers = {
                'Authorization': `Bearer ${this.elements.tokenInput.value}`,
                'Content-Type': 'application/json',
                ...options.headers,
            };
            try {
                const response = await fetch(`${this.elements.serverUrl.value}${endpoint}`, { ...options, headers });
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ message: response.statusText }));
                    console.error(`API Error ${response.status} for ${endpoint}:`, errorData);
                    alert(`Error: ${errorData.message || 'Failed to fetch data.'}`);
                    if (response.status === 401) {
                        this.updateConnectionStatus('Unauthorized. Reconnecting...', 'error');
                        this.disconnect(); // Auto-disconnect on auth error
                    }
                    return null;
                }
                if (response.status === 204) return true; // No content success
                return response.json();
            } catch (error) {
                console.error(`Network or fetch error for ${endpoint}:`, error);
                alert(`Network error: ${error.message || 'Failed to connect to server.'}`);
                this.updateConnectionStatus('Network Error', 'error');
                return null;
            }
        }


        async loadConversations() {
            if (!this.socket || !this.socket.connected || !this.currentUser) {
                console.warn("Cannot load conversations: not connected or no current user.");
                return;
            }
            this.elements.conversationsList.innerHTML = '<div class="empty-state"><p>Loading discussions...</p></div>';

            const conversationsData = await this.fetchApi('/chat/conversations');
            if (conversationsData) {
                this.conversations.clear();
                // Ensure conversation.id is "partnerDoctorId-patientId"
                conversationsData.forEach(conv => this.conversations.set(conv.id, conv));
                this.renderConversations();
            } else {
                this.elements.conversationsList.innerHTML = '<div class="empty-state"><h3>Failed to load</h3><p>Try refreshing or check connection.</p></div>';
            }
        }

        renderConversations() {
            const container = this.elements.conversationsList;
            if (!this.conversations || this.conversations.size === 0) {
                container.innerHTML = `<div class="empty-state"><h3>No discussions</h3><p>Start a new one below.</p></div>`;
                return;
            }

            const sortedConversations = Array.from(this.conversations.values()).sort((a, b) => {
                const dateA = a.lastMessage ? new Date(a.lastMessage.createdAt) : new Date(0);
                const dateB = b.lastMessage ? new Date(b.lastMessage.createdAt) : new Date(0);
                return dateB - dateA;
            });


            container.innerHTML = sortedConversations.map(conv => {
                const doctor = conv.partnerDoctor; // This is the OTHER doctor
                const patient = conv.patient;
                const lastMessage = conv.lastMessage;
                const unreadCount = conv.unreadCount || 0;

                const avatarText = `${doctor.first_name?.[0] || 'Dr'}${doctor.last_name?.[0] || ''}`.toUpperCase();
                const fullName = `${doctor.first_name || 'Doctor'} ${doctor.last_name || ''}`.trim();
                const patientName = patient.name || `Patient ${patient.id.substring(0,8)}`;

                let preview = 'No messages yet';
                if (lastMessage) {
                    if (lastMessage.content) {
                        preview = lastMessage.content.length > 30 ? lastMessage.content.substring(0, 27) + '...' : lastMessage.content;
                    } else if (lastMessage.attachments?.length > 0) {
                        preview = '📎 Attachment';
                    }
                }
                let timeText = lastMessage ? this.formatTime(lastMessage.createdAt) : '';
                const conversationId = conv.id; // "partnerDoctorId-patientId"

                return `
                    <div class="conversation-item ${this.currentConversation?.id === conversationId ? 'active' : ''}"
                         data-conversation-id="${conversationId}"
                         onclick="chatApp.selectConversation('${conversationId}')">
                        <div class="conversation-avatar" style="${doctor.profile_image ? `background-image:url(${doctor.profile_image}); background-size:cover;` : ''}">${!doctor.profile_image ? avatarText : ''}</div>
                        <div class="conversation-info">
                            <div class="conversation-name">${fullName}</div>
                            <div class="conversation-patient">Re: ${patientName}</div>
                            <div class="conversation-preview">${preview}</div>
                        </div>
                        <div class="conversation-meta">
                            ${timeText ? `<div class="conversation-time">${timeText}</div>` : ''}
                            ${unreadCount > 0 ? `<div class="unread-badge">${unreadCount}</div>` : ''}
                        </div>
                    </div>`;
            }).join('');
        }

        handleStartNewConversation() {
            if (!this.currentUser) {
                alert("Cannot start conversation: current user not identified.");
                return;
            }
            const patientId = this.elements.newPatientIdInput.value.trim();
            const otherDoctorId = this.elements.newDoctorIdInput.value.trim();

            if (!patientId || !otherDoctorId) {
                alert("Please provide both Patient ID and other Doctor ID.");
                return;
            }
            if (otherDoctorId === this.currentUser.id) {
                alert("You cannot start a conversation with yourself.");
                return;
            }
            const uuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/;
            if (!uuidRegex.test(patientId) || !uuidRegex.test(otherDoctorId)) {
                alert("Patient ID and Doctor ID must be valid UUIDs.");
                return;
            }

            const conversationId = `${otherDoctorId}-${patientId}`; // Consistent ID format

            if (this.conversations.has(conversationId)) {
                this.selectConversation(conversationId);
            } else {
                // Create a temporary conversation object to open the chat window.
                // Backend will fully create it on first message or API call if needed.
                // For now, we need partnerDoctor and patient objects for selectConversation.
                // We assume these IDs are enough to fetch details if needed, or use placeholders.
                const tempNewConv = {
                    id: conversationId,
                    partnerDoctor: { id: otherDoctorId, first_name: "Doctor", last_name: otherDoctorId.substring(0,8), profile_image: null, specialty: "Unknown" },
                    patient: { id: patientId, name: `Patient ${patientId.substring(0,8)}` },
                    lastMessage: null,
                    unreadCount: 0
                };
                this.conversations.set(conversationId, tempNewConv);
                this.renderConversations();
                this.selectConversation(conversationId);
            }
            this.elements.newPatientIdInput.value = '';
            this.elements.newDoctorIdInput.value = '';
        }


        async selectConversation(conversationId) { // conversationId is "partnerDoctorId-patientId"
            const conversation = this.conversations.get(conversationId);
            if (!conversation) {
                console.error("Selected conversation not found in map:", conversationId);
                alert("Error: Could not open conversation.");
                return;
            }

            this.currentConversation = {
                id: conversation.id,
                partnerDoctorId: conversation.partnerDoctor.id,
                patientId: conversation.patient.id,
                patientName: conversation.patient.name || `Patient ${conversation.patient.id.substring(0,8)}`,
                partnerDoctorName: `${conversation.partnerDoctor.first_name || 'Doctor'} ${conversation.partnerDoctor.last_name || ''}`.trim(),
                partnerDoctorAvatar: conversation.partnerDoctor.profile_image,
                partnerDoctorSpecialty: conversation.partnerDoctor.specialty || 'Doctor',
            };

            document.querySelectorAll('.conversation-item').forEach(item => item.classList.remove('active'));
            const currentConvElement = document.querySelector(`[data-conversation-id="${conversationId}"]`);
            if (currentConvElement) currentConvElement.classList.add('active');

            this.renderChatInterface();
            await this.loadMessages(true);

            if (conversation.unreadCount > 0) {
                // Optimistically update UI for unread count
                conversation.unreadCount = 0;
                this.renderConversations(); // Re-render list to remove badge

                // Inform backend that messages are read (implicitly by opening chat, or more explicitly)
                // For simplicity, we assume messages loaded are marked as read by the recipient (current user)
                // A more robust way is to iterate through loaded messages and send 'markAsRead' for unread ones received by current user.
                const messagesData = this.messages.get(this.currentConversation.id);
                if (messagesData && messagesData.messages) {
                    messagesData.messages.forEach(msg => {
                        // If the message was from the partner and not read by current user
                        if (msg.senderId === this.currentConversation.partnerDoctorId && !msg.isRead && this.currentUser && msg.receiverId === this.currentUser.id) {
                            this.socket.emit('markAsRead', { messageId: msg.id, patientId: this.currentConversation.patientId });
                        }
                    });
                }
            }
        }

        async loadMessages(isInitialLoad = false) {
            if (!this.socket || !this.socket.connected || !this.currentConversation || !this.currentUser) return;

            const { partnerDoctorId, patientId, id: conversationId } = this.currentConversation;
            let currentMessagesData = this.messages.get(conversationId);

            if (isInitialLoad) {
                this.messages.set(conversationId, { messages: [], hasMore: true, nextCursor: null });
                currentMessagesData = this.messages.get(conversationId);
                const messagesContentEl = document.getElementById('messagesContent');
                if (messagesContentEl) messagesContentEl.innerHTML = '<div class="empty-state"><p>Loading messages...</p></div>';
            }

            const loadMoreBtn = document.getElementById('loadMoreMessagesBtn');
            if (!currentMessagesData.hasMore && !isInitialLoad) {
                if(loadMoreBtn) loadMoreBtn.disabled = true;
                return;
            }
            if(loadMoreBtn && !isInitialLoad) loadMoreBtn.disabled = true; // Disable while loading

            const cursor = currentMessagesData.nextCursor;
            // The otherDoctorId for the API is currentConversation.partnerDoctorId
            const url = `/chat/messages?doctorId=${partnerDoctorId}&patientId=${patientId}&limit=20${cursor ? '&cursor=' + cursor : ''}`;
            const data = await this.fetchApi(url);

            if(loadMoreBtn && !isInitialLoad) loadMoreBtn.disabled = !(data && data.hasMore);


            if (data && data.messages) {
                const newMessages = data.messages; // API returns newest first with cursor logic, so should be newest to oldest
                currentMessagesData.messages = isInitialLoad ? newMessages.reverse() : [...newMessages.reverse(), ...currentMessagesData.messages];
                currentMessagesData.hasMore = data.hasMore;
                currentMessagesData.nextCursor = data.nextCursor;
                this.messages.set(conversationId, currentMessagesData);
                this.renderMessages(isInitialLoad); // Scroll to bottom on initial load
            } else if (isInitialLoad) {
                const messagesContentEl = document.getElementById('messagesContent');
                if(messagesContentEl) messagesContentEl.innerHTML = '<div class="empty-state"><h3>No messages</h3><p>Start the conversation!</p></div>';
                if(loadMoreBtn) loadMoreBtn.style.display = 'none';
            }
        }

        renderChatInterface() {
            if (!this.currentConversation) {
                this.elements.chatContent.innerHTML = '<div class="empty-state"><h3>Error</h3><p>No conversation selected.</p></div>';
                return;
            }
            const { partnerDoctorName, patientName, partnerDoctorAvatar, partnerDoctorSpecialty } = this.currentConversation;
            const avatarText = partnerDoctorName.split(" ").map(n => n[0]).filter(Boolean).join("").toUpperCase() || 'DR';

            this.elements.chatContent.innerHTML = `
                <div class="chat-header">
                    <div class="chat-avatar" style="${partnerDoctorAvatar ? `background-image:url(${partnerDoctorAvatar}); background-size:cover;` : ''}">${!partnerDoctorAvatar ? avatarText : ''}</div>
                    <div class="chat-info">
                        <h3>${partnerDoctorName}</h3>
                        <div class="patient-context">Discussion about: ${patientName}</div>
                        <div class="chat-status" id="chatPartnerStatus">${partnerDoctorSpecialty || 'Doctor'}</div>
                    </div>
                </div>
                <div class="messages-container" id="messagesContainer">
                    <div class="load-more" id="loadMoreContainer">
                        <button id="loadMoreMessagesBtn" onclick="chatApp.loadMessages(false)" disabled>Load Older Messages</button>
                    </div>
                    <div id="messagesContent"></div>
                    <div class="typing-indicator" id="typingIndicator">
                        <div class="typing-bubble"><div class="typing-dots"><div class="typing-dot"></div><div class="typing-dot"></div><div class="typing-dot"></div></div></div>
                    </div>
                </div>
                <div class="message-input-container">
                    <div class="file-preview" id="filePreview"></div>
                    <div class="message-input-wrapper">
                        <div class="input-actions">
                            <button class="action-btn" onclick="chatApp.elements.fileInput.click()" title="Attach file">📎</button>
                        </div>
                        <textarea class="message-input" id="messageInput" placeholder="Type a message..." rows="1" onkeydown="chatApp.handleInputKeydown(event)" oninput="chatApp.handleInputChange(event)"></textarea>
                        <div class="input-actions">
                            <button class="action-btn send-btn" id="sendBtn" onclick="chatApp.sendMessage()" title="Send message" disabled>➤</button>
                        </div>
                    </div>
                </div>
                <button class="scroll-to-bottom" id="scrollToBottomBtn" onclick="chatApp.scrollToBottom()">↓</button>`;

            const msgContainer = document.getElementById('messagesContainer');
            msgContainer.addEventListener('scroll', () => this.handleScroll(msgContainer));

            const messageInputEl = document.getElementById('messageInput');
            messageInputEl.addEventListener('input', () => {
                document.getElementById('sendBtn').disabled = messageInputEl.value.trim() === '' && this.selectedFiles.length === 0;
            });
            document.getElementById('sendBtn').disabled = true; // Initially disable send button
        }

        renderMessages(scrollToBottomIfAtBottom = true) {
            if (!this.currentConversation || !this.currentUser) return;
            const conversationId = this.currentConversation.id;
            const messagesData = this.messages.get(conversationId);
            const container = document.getElementById('messagesContent');
            const loadMoreBtn = document.getElementById('loadMoreMessagesBtn');
            const msgContainer = document.getElementById('messagesContainer');

            if (!container || !messagesData) return;

            const shouldScroll = scrollToBottomIfAtBottom && msgContainer && (msgContainer.scrollHeight - msgContainer.scrollTop - msgContainer.clientHeight < 100);


            if (loadMoreBtn) {
                loadMoreBtn.disabled = !messagesData.hasMore;
                document.getElementById('loadMoreContainer').style.display = messagesData.messages.length === 0 && !messagesData.hasMore ? 'none' : (messagesData.hasMore ? 'block' : 'none');
            }


            if (messagesData.messages.length === 0) {
                container.innerHTML = `<div class="empty-state" style="padding:50px 0;"><h3>No messages yet</h3><p>Start the discussion!</p></div>`;
                return;
            }

            let html = '';
            let currentDate = '';
            messagesData.messages.forEach(message => {
                const messageDate = new Date(message.createdAt).toDateString();
                if (messageDate !== currentDate) {
                    currentDate = messageDate;
                    html += `<div class="message-date">${this.formatDate(message.createdAt)}</div>`;
                }
                const isOwn = message.senderId === this.currentUser.id;
                const time = this.formatTime(message.createdAt);

                html += `
                    <div class="message ${isOwn ? 'own' : ''}" data-message-id="${message.id}">
                        <div class="message-bubble">
                            ${message.content.replace(/\n/g, '<br>')}
                            ${this.renderAttachments(message.attachments)}
                        </div>
                        <div class="message-actions">
                           ${isOwn ? `<button class="message-action-btn" title="Delete" onclick="chatApp.confirmDeleteMessage('${message.id}')">🗑️</button>` : ''}
                        </div>
                    </div>
                    <div class="message-time ${isOwn ? 'own' : ''}">
                        ${time}
                        ${isOwn ? (message.isRead ? '<span class="message-read-status">✓✓</span>' : '✓') : ''}
                    </div>`;
            });
            container.innerHTML = html;

            if (shouldScroll) {
                this.scrollToBottom();
            }
        }

        confirmDeleteMessage(messageId) {
            if (confirm("Are you sure you want to delete this message? This cannot be undone.")) {
                this.deleteMessage(messageId);
            }
        }

        deleteMessage(messageId) {
            if (!this.socket || !this.socket.connected || !this.currentConversation) return;
            // For socket emission, we need receiverId to be the partner doctor.
            this.socket.emit('deleteMessage', {
                messageId: messageId,
                patientId: this.currentConversation.patientId,
                receiverId: this.currentConversation.partnerDoctorId
            });
        }

        handleMessageDeleted(data) { // { messageId, patientId }
            if (this.currentConversation && this.currentConversation.patientId === data.patientId) {
                const messagesData = this.messages.get(this.currentConversation.id);
                if (messagesData) {
                    messagesData.messages = messagesData.messages.filter(m => m.id !== data.messageId);
                    this.renderMessages(false);
                }
            }
            // Refresh conversations list to update last message preview if needed
            const convToUpdate = this.conversations.get(`${this.currentConversation?.partnerDoctorId}-${data.patientId}`) || this.conversations.get(`${data.senderId}-${data.patientId}`);
            if(convToUpdate && convToUpdate.lastMessage && convToUpdate.lastMessage.id === data.messageId) {
                this.loadConversations(); // Reload all conversations for simplicity to update last message
            }
        }


        renderAttachments(attachments) {
            if (!attachments || attachments.length === 0) return '';
            return `<div class="message-attachments">
                ${attachments.map(att => `
                    <div class="attachment-item">
                        <a href="${att.url || '#'}" target="_blank" title="Download ${att.filename} (${att.size ? (att.size / 1024).toFixed(1) + ' KB' : ''})">
                            📎 ${att.filename.length > 20 ? att.filename.substring(0,17)+'...' : att.filename}
                        </a>
                    </div>`).join('')}
            </div>`;
        }

        formatDate(dateStr) {
            const d = new Date(dateStr);
            const today = new Date();
            const yesterday = new Date(today);
            yesterday.setDate(yesterday.getDate() - 1);

            if (d.toDateString() === today.toDateString()) return 'Today';
            if (d.toDateString() === yesterday.toDateString()) return 'Yesterday';
            return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: d.getFullYear() !== today.getFullYear() ? 'numeric' : undefined });
        }
        formatTime(dateStr) {
            return new Date(dateStr).toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
        }

        handleScroll(container) {
            const scrollToBottomBtn = document.getElementById('scrollToBottomBtn');
            if (scrollToBottomBtn) {
                const isNearBottom = container.scrollHeight - container.scrollTop - container.clientHeight < 200;
                scrollToBottomBtn.classList.toggle('show', !isNearBottom && container.scrollHeight > container.clientHeight + 50);
            }

            // Load more messages when scrolling to the top
            if (container.scrollTop < 50 && this.currentConversation) {
                const messagesData = this.messages.get(this.currentConversation.id);
                if (messagesData && messagesData.hasMore) {
                    const loadMoreBtn = document.getElementById('loadMoreMessagesBtn');
                    if (loadMoreBtn && !loadMoreBtn.disabled) {
                        this.loadMessages(false); // Pass false for not initial load
                    }
                }
            }
        }
        scrollToBottom() {
            const container = document.getElementById('messagesContainer');
            if (container) container.scrollTop = container.scrollHeight;
        }

        handleInputKeydown(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                const sendBtn = document.getElementById('sendBtn');
                if(!sendBtn.disabled) this.sendMessage();
            }
        }
        handleInputChange(event) {
            const input = event.target;
            input.style.height = 'auto';
            input.style.height = Math.min(input.scrollHeight, 100) + 'px'; // Max height 100px
            document.getElementById('sendBtn').disabled = input.value.trim() === '' && this.selectedFiles.length === 0;

            if (!this.currentConversation || !this.socket || !this.socket.connected) return;

            if (!this.isTyping) {
                this.isTyping = true;
                this.socket.emit('startTyping', { receiverId: this.currentConversation.partnerDoctorId, patientId: this.currentConversation.patientId });
            }
            clearTimeout(this.typingTimeout);
            this.typingTimeout = setTimeout(() => {
                this.isTyping = false;
                this.socket.emit('stopTyping', { receiverId: this.currentConversation.partnerDoctorId, patientId: this.currentConversation.patientId });
            }, 2000);
        }

        handleFileSelect(event) {
            const files = Array.from(event.target.files);
            if (this.selectedFiles.length + files.length > 5) {
                alert("You can select a maximum of 5 files.");
                event.target.value = null; return;
            }
            for (let file of files) {
                if (file.size > 10 * 1024 * 1024) { // 10 MB
                    alert(`File ${file.name} is too large (max 10MB).`);
                    continue;
                }
                this.selectedFiles.push(file);
            }
            this.renderFilePreview();
            document.getElementById('sendBtn').disabled = document.getElementById('messageInput').value.trim() === '' && this.selectedFiles.length === 0;
            event.target.value = null;
        }

        renderFilePreview() {
            const container = document.getElementById('filePreview');
            if (!container) return;
            if (this.selectedFiles.length === 0) { container.innerHTML = ''; return; }
            container.innerHTML = this.selectedFiles.map((file, index) => `
                <div class="file-item">
                    <div class="file-info">
                        <span>📎</span>
                        <span>${file.name.length > 30 ? file.name.substring(0,27)+'...' : file.name} (${(file.size/1024).toFixed(1)}KB)</span>
                    </div>
                    <button class="remove-file" onclick="chatApp.removeFile(${index})" title="Remove file">×</button>
                </div>`).join('');
        }
        removeFile(index) {
            this.selectedFiles.splice(index, 1);
            this.renderFilePreview();
            document.getElementById('sendBtn').disabled = document.getElementById('messageInput').value.trim() === '' && this.selectedFiles.length === 0;
        }

        async sendMessage() {
            if (!this.socket || !this.socket.connected || !this.currentConversation || !this.currentUser) return;
            const input = document.getElementById('messageInput');
            const content = input.value.trim();
            if (!content && this.selectedFiles.length === 0) return;

            const sendBtn = document.getElementById('sendBtn');
            const originalSendBtnText = sendBtn.innerHTML;
            sendBtn.disabled = true;
            sendBtn.innerHTML = '...';


            try {
                let uploadedAttachments = [];
                if (this.selectedFiles.length > 0) {
                    const formData = new FormData();
                    this.selectedFiles.forEach(file => formData.append('files', file));

                    const uploadResponse = await fetch(`${this.elements.serverUrl.value}/chat/upload`, {
                        method: 'POST',
                        headers: { 'Authorization': `Bearer ${this.elements.tokenInput.value}` },
                        body: formData
                    });

                    if (uploadResponse.ok) {
                        const result = await uploadResponse.json();
                        if (result.files && Array.isArray(result.files)) {
                            uploadedAttachments = result.files; // These should be AttachmentDto[]
                        } else {
                            throw new Error("Uploaded files data not in expected format from server.");
                        }
                    } else {
                        const errorData = await uploadResponse.json().catch(()=>({message: "File upload failed with no error details."}));
                        throw new Error(`File upload failed: ${errorData.message || uploadResponse.statusText}`);
                    }
                }

                this.socket.emit('sendMessage', {
                    content: content,
                    receiverId: this.currentConversation.partnerDoctorId,
                    patientId: this.currentConversation.patientId,
                    attachments: uploadedAttachments // Send AttachmentDto[]
                });

                input.value = '';
                input.style.height = 'auto';
                this.selectedFiles = [];
                this.renderFilePreview();
                // Send button will be re-enabled by input change if needed, or kept disabled
                document.getElementById('sendBtn').disabled = true;


            } catch (error) {
                console.error('Error sending message:', error);
                alert(`Failed to send message: ${error.message}`);
                sendBtn.disabled = false; // Re-enable on error
            } finally {
                sendBtn.innerHTML = originalSendBtnText; // Restore button text
                // Final check on send button state
                if (document.getElementById('messageInput').value.trim() === '' && this.selectedFiles.length === 0) {
                    sendBtn.disabled = true;
                } else {
                    sendBtn.disabled = false;
                }

            }
        }

        handleNewMessage(message, isOwnSentMessage) {
            if (!message || !message.patientId || !this.currentUser) {
                console.warn("Received malformed message or currentUser not set:", message);
                return;
            }

            // Determine the conversation ID based on sender/receiver and patient
            // If it's our own sent message, the partner is the receiverId
            // If it's an incoming message, the partner is the senderId
            const partnerId = isOwnSentMessage ? message.receiverId : message.senderId;
            if (!partnerId) {
                console.warn("Could not determine partner ID from message:", message);
                return;
            }
            const conversationId = `${partnerId}-${message.patientId}`;


            let conversationMessages = this.messages.get(conversationId);
            if (!conversationMessages) {
                this.messages.set(conversationId, { messages: [], hasMore: false, nextCursor: null });
                conversationMessages = this.messages.get(conversationId);
            }

            const existingMessage = conversationMessages.messages.find(m => m.id === message.id);
            if (!existingMessage) {
                conversationMessages.messages.push(message);
            } else { // Update existing message (e.g. if messageSent comes after newMessage with more details)
                Object.assign(existingMessage, message);
            }


            if (this.currentConversation && this.currentConversation.id === conversationId) {
                this.renderMessages(true);
                if (!isOwnSentMessage && message.senderId === this.currentConversation.partnerDoctorId) {
                    this.socket.emit('markAsRead', { messageId: message.id, patientId: message.patientId });
                }
            }

            const convData = this.conversations.get(conversationId);
            if (convData) {
                convData.lastMessage = message;
                if (!isOwnSentMessage && message.senderId === partnerId && (!this.currentConversation || this.currentConversation.id !== conversationId)) {
                    convData.unreadCount = (convData.unreadCount || 0) + 1;
                } else if (this.currentConversation && this.currentConversation.id === conversationId) {
                    convData.unreadCount = 0; // We are viewing the chat, so reset unread
                }
                this.renderConversations();
            } else if (!isOwnSentMessage) {
                // New message for a conversation not in the list (e.g., new doctor initiated)
                this.loadConversations(); // Reload all conversations to include the new one
            }
        }

        handleMessageRead(data) { // { messageId, patientId, readBy (the one who read it) }
            if (!this.currentUser) return;

            const conversationIdForMessage = this.findConversationIdForMessage(data.messageId, data.patientId);
            if (!conversationIdForMessage) return;

            const messagesData = this.messages.get(conversationIdForMessage);
            if (messagesData) {
                const msgToUpdate = messagesData.messages.find(m => m.id === data.messageId);
                // If the message was sent by me (currentUser) and read by the other party (data.readBy is my partner)
                if (msgToUpdate && msgToUpdate.senderId === this.currentUser.id && data.readBy !== this.currentUser.id) {
                    msgToUpdate.isRead = true;
                    if (this.currentConversation && this.currentConversation.id === conversationIdForMessage) {
                        this.renderMessages(false); // Re-render without scrolling if current chat
                    }
                }
            }
            // If this read receipt is for a message in the currently open chat, update its unread count (should be 0)
            if (this.currentConversation && this.currentConversation.id === conversationIdForMessage) {
                const convInList = this.conversations.get(this.currentConversation.id);
                if (convInList) {
                    // convInList.unreadCount = 0; // This should already be handled by opening the chat.
                    // More for updating the "read ticks" on sent messages.
                }
            }
        }

        findConversationIdForMessage(messageId, patientId) {
            for (const [convId, data] of this.messages.entries()) {
                if (data.messages.some(m => m.id === messageId && m.patientId === patientId)) {
                    // convId is "partnerId-patientId"
                    // We need to ensure this is the correct partner
                    return convId;
                }
            }
            return null;
        }


        handleTyping(data) { // { doctorId (who is typing), patientId, isTyping }
            if (this.currentConversation &&
              this.currentConversation.partnerDoctorId === data.doctorId &&
              this.currentConversation.patientId === data.patientId) {
                const indicator = document.getElementById('typingIndicator');
                if (indicator) {
                    if (data.isTyping) {
                        indicator.classList.add('show');
                        this.scrollToBottom(); // Scroll to show indicator if user is near bottom
                        clearTimeout(this.typingCleanupTimeout);
                        this.typingCleanupTimeout = setTimeout(() => {
                            if(indicator.classList.contains('show')) indicator.classList.remove('show');
                        }, 4000); // Safety net to hide if stopTyping not received
                    } else {
                        indicator.classList.remove('show');
                        clearTimeout(this.typingCleanupTimeout);
                    }
                }
            }
        }
    }
    const chatApp = new ChatApp();
</script>
</body>
</html>